<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Create Exam | CBT System</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* General Styles */
    body { font-family: 'Inter', sans-serif; background-color: #f4f7f6; color: #333; line-height: 1.6; }
    main { max-width: 900px; margin: 30px auto; padding: 20px; background: #fff; border-radius: 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.08); }
    h1, h2, h3 { color: var(--primary-blue); margin-bottom: 1.5rem; }
    hr { border: none; border-top: 1px solid #e0e0e0; margin: 2rem 0; }
    
    /* Form Specifics */
    .app-form { display: flex; flex-direction: column; gap: 1.5rem; }
    .form-group { margin-bottom: 1rem; }
    .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 600; color: #555; }
    .form-group input[type="text"],
    .form-group input[type="number"],
    .form-group select,
    .form-group textarea,
    .form-group input[type="datetime-local"] { /* Added datetime-local */
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ccc;
      border-radius: 8px; /* Slightly more rounded */
      font-size: 1rem;
      box-sizing: border-box; /* Include padding in width */
    }
    .form-group input[type="checkbox"] { width: auto; margin-right: 10px; }

    .form-grid-col-3 { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; }

    /* Buttons */
    .btn {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .primary-btn { background-color: var(--primary-blue); color: white; }
    .primary-btn:hover { background-color: var(--primary-dark); transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .danger-btn { background-color: var(--danger-red); color: white; }
    .danger-btn:hover { background-color: #cc0000; transform: translateY(-1px); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
    .add-question-btn, .add-section-btn { background-color: #28a745; color: white; margin-top: 15px; } /* Green for add buttons */
    .add-question-btn:hover, .add-section-btn:hover { background-color: #218838; }

    /* Section and Question Cards */
    .section-card {
      background: #eef4ff; /* Lighter blue background */
      border: 1px solid #c9d9ff;
      border-radius: 12px; /* Consistent rounding */
      padding: 25px;
      margin-bottom: 30px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    }
    .section-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #b3caff; }
    .section-header h2 { margin: 0; color: var(--primary-blue); }
    .section-actions { display: flex; gap: 10px; }
    .section-instructions, .exam-instructions { min-height: 80px; resize: vertical; }

    .question-card {
      background: #f8f9ff;
      border: 1px solid #e0e5ff;
      border-radius: 10px; /* Consistent rounding */
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #d1d9ff; }
    .question-header h3 { margin: 0; color: var(--primary-blue); }
    .delete-question-btn { background-color: var(--danger-red); color: white; padding: 6px 12px; font-size: 0.9em; }

    /* Messages */
    .error-message, .info-message, .success-message {
        padding: 10px 15px;
        border-radius: 8px;
        margin-bottom: 1rem;
        text-align: center;
        font-weight: 500;
    }
    .error-message { background-color: #ffebeb; color: var(--danger-red); border: 1px solid var(--danger-red); }
    .info-message { background-color: #e0f7fa; color: #007bb5; border: 1px solid #00acc1; }
    .success-message { background-color: #e6ffed; color: var(--success-green); border: 1px solid var(--success-green); }
    .hidden { display: none; }

    /* Footer */
    footer { text-align: center; padding: 20px; margin-top: 2rem; color: #777; font-size: 0.9em; }

    /* Navbar Styles (copied for consistency) */
    header { background-color: #1a237e; padding: 1rem 0; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15); font-family: 'Inter', sans-serif; }
    nav { display: flex; justify-content: space-between; align-items: center; max-width: 1200px; margin: 0 auto; padding: 0 20px; }
    nav .logo { color: #e8eaf6; font-size: 1.8rem; font-weight: 700; text-decoration: none; transition: color 0.3s ease; }
    nav .logo:hover { color: #ffffff; }
    .nav-links { list-style: none; margin: 0; padding: 0; display: flex; gap: 25px; }
    .nav-links li { position: relative; }
    .nav-links .nav-link {
        color: #c5cae9; text-decoration: none; font-size: 1.05rem; font-weight: 500; padding: 8px 0;
        transition: color 0.3s ease, transform 0.2s ease; position: relative; white-space: nowrap;
    }
    .nav-links .nav-link::after { content: ''; position: absolute; left: 0; bottom: 0; width: 0; height: 2px; background-color: #ffffff; transition: width 0.3s ease; }
    .nav-links .nav-link:hover { color: #ffffff; transform: translateY(-2px); }
    .nav-links .nav-link:hover::after, .nav-links .nav-link.active::after { width: 100%; }
    .logout-btn { background-color: #f44336; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-size: 1rem; }
    .logout-btn:hover { background-color: #d32f2f; }
    @media (max-width: 768px) {
        nav { flex-direction: column; align-items: flex-start; }
        .nav-links { flex-direction: column; width: 100%; gap: 5px; margin-top: 15px; }
        .nav-links .nav-link { padding: 10px 15px; width: calc(100% - 30px); border-radius: 6px; }
        .nav-links .nav-link:hover::after, .nav-links .nav-link.active::after { width: 0; }
        .nav-links .nav-link:hover { background-color: rgba(255, 255, 255, 0.1); transform: none; }
    }
    /* Modals */
    .modal {
        display: none; /* Hidden by default */
        position: fixed; /* Stay in place */
        z-index: 1000; /* Sit on top */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        overflow: auto; /* Enable scroll if needed */
        background-color: rgba(0,0,0,0.4); /* Black w/ opacity */
        display: flex; /* Use flexbox for centering */
        align-items: center; /* Center vertically */
        justify-content: center; /* Center horizontally */
    }
    .modal-content {
        background-color: #fefefe;
        margin: auto;
        padding: 0;
        border: 1px solid #888;
        width: 80%; /* Could be responsive */
        max-width: 500px;
        border-radius: 10px; /* Rounded corners */
        box-shadow: 0 8px 30px rgba(0,0,0,0.25);
        overflow: hidden; /* Ensures rounded corners on content */
    }
    .modal-header {
        padding: 15px 20px;
        background-color: var(--primary-blue);
        color: white;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-radius: 10px 10px 0 0;
    }
    .modal-header h2 {
        margin: 0;
        font-size: 1.2rem;
    }
    .modal-body {
        padding: 20px;
        text-align: center;
    }
    .modal-footer {
        padding: 15px 20px;
        background-color: #f1f1f1;
        text-align: right;
        border-top: 1px solid #e0e0e0;
        border-radius: 0 0 10px 10px;
    }
    .close-button {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        transition: color 0.3s ease;
    }
    .close-button:hover,
    .close-button:focus {
        color: #ddd;
        text-decoration: none;
        cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <nav>
      <a href="/dashboard.html" class="logo">SNA CBT System</a>
      <ul class="nav-links" id="navLinksContainer">
        </ul>
    </nav>
  </header>

  <main>
    <div class="container">
      <h1>Create New Exam</h1>
      <form id="createExamForm" class="app-form">
        <div id="formMessage" class="hidden"></div> <!-- Unified message display -->

        <div class="form-group">
          <label for="examTitle">Exam Title:</label>
          <input type="text" id="examTitle" name="examTitle" required>
        </div>

        <div class="form-grid-col-3">
          <div class="form-group">
            <label for="classLevel">Class Level:</label>
            <select id="classLevel" name="classLevel" required>
              <option value="">Select Class Level</option>
            </select>
          </div>

          <div class="form-group">
            <label for="subject">Subject:</label>
            <select id="subject" name="subject" required disabled>
              <option value="">Select Subject</option>
            </select>
          </div>

          <div class="form-group">
            <label for="duration">Duration (minutes):</label>
            <input type="number" id="duration" name="duration" min="1" value="60" required>
          </div>
        </div>

        <!-- NEW: Term and Session fields -->
        <div class="form-grid-col-3">
            <div class="form-group">
                <label for="term">Term:</label>
                <select id="term" name="term" required>
                    <option value="">Select Term</option>
                    <option value="FIRST">First Term</option>
                    <option value="SECOND">Second Term</option>
                    <option value="THIRD">Third Term</option>
                </select>
            </div>
            <div class="form-group">
                <label for="session">Academic Session:</label>
                <!-- Changed session from select to text input with pattern -->
                <input type="text" id="session" name="session" required pattern="\d{4}-\d{4}" placeholder="e.g., 2023-2024">
            </div>
        </div>

        <div class="form-group">
          <label for="passMark">Pass Mark:</label>
          <input type="number" id="passMark" name="passMark" min="0" required>
        </div>

        <div class="form-grid-col-3">
            <div class="form-group">
                <label for="startTime">Start Time:</label>
                <input type="datetime-local" id="startTime" name="startTime" required>
            </div>
            <div class="form-group">
                <label for="endTime">End Time:</label>
                <input type="datetime-local" id="endTime" name="endTime" required>
            </div>
        </div>
        
        <div class="form-group">
          <label for="examType">Exam Type:</label>
          <select id="examType" name="examType" required>
            <option value="">Select Exam Type</option>
            <option value="CA1">Continuous Assessment 1 (CA1)</option>
            <option value="CA2">Continuous Assessment 2 (CA2)</option>
            <option value="CA3">Continuous Assessment 3 (CA3)</option>
            <option value="CA4">Continuous Assessment 4 (CA4)</option>
            <option value="MID_TERM">Mid Term Test</option>
            <option value="MAIN_EXAM">General Exam</option>
            <option value="OTHER">Other Assessment</option>
          </select>
        </div>

        <div class="form-group">
          <input type="checkbox" id="isLocked" name="isLocked">
          <label for="isLocked">Lock Exam (Students cannot take it until unlocked)</label>
        </div>

        <div class="form-group">
            <label for="maxScore">Total Marks for Exam:</label>
            <input type="number" id="maxScore" name="maxScore" required min="1">
            <small>Sum of marks from all questions should ideally match this.</small>
        </div>
        <div class="form-group" style="margin-top: 10px;">
            <p>Calculated total marks from questions: <span id="calculatedMarksDisplay">0</span></p>
            <p id="marksMismatchWarning" style="color: var(--danger-red); display: none;"></p>
        </div>

        <div class="form-group">
          <label for="examInstructions">General Exam Instructions:</label>
          <textarea id="examInstructions" name="examInstructions" rows="4" class="exam-instructions" placeholder="Enter general instructions for the exam..."></textarea>
        </div>

        <hr>
        <h2>Exam Sections</h2>
        <div id="sectionsContainer">
          </div>

        <button type="button" id="addSectionBtn" class="add-section-btn">Add Section</button>
        <button type="submit" class="btn primary-btn" id="submitExamBtn">Create Exam</button>
      </form>
    </div>
  </main>

  <footer>
    <p>&copy; 2024 SNA CBT System. All rights reserved.</p>
  </footer>

  <script>
    let currentUser = null;
    let questionCounter = 0; // Global counter for unique question IDs
    let sectionCounter = 0; // Global counter for unique section IDs
    let allSubjects = []; // To store all subjects from the backend
    let allClassLevels = []; // To store all class levels from the backend

    const classLevelSelect = document.getElementById('classLevel');
    const subjectSelect = document.getElementById('subject');
    const termSelect = document.getElementById('term');
    const sessionInput = document.getElementById('session');
    const examTypeSelect = document.getElementById('examType');
    const isLockedCheckbox = document.getElementById('isLocked');
    const sectionsContainer = document.getElementById('sectionsContainer');
    const addSectionBtn = document.getElementById('addSectionBtn');
    const examForm = document.getElementById('createExamForm');
    const maxScoreInput = document.getElementById('maxScore'); // Changed from totalMarks
    const passMarkInput = document.getElementById('passMark');
    const startTimeInput = document.getElementById('startTime');
    const endTimeInput = document.getElementById('endTime');
    const formMessageDiv = document.getElementById('formMessage');

    // Displays a message to the user (success, error, info).
    function showMessage(message, type = 'error') {
        formMessageDiv.textContent = message;
        formMessageDiv.classList.remove('hidden', 'error-message', 'success-message', 'info-message');
        if (type === 'error') {
            formMessageDiv.classList.add('error-message');
        } else if (type === 'success') {
            formMessageDiv.classList.add('success-message');
        } else {
            formMessageDiv.classList.add('info-message');
        }
        setTimeout(() => {
            formMessageDiv.classList.add('hidden');
        }, 5000); // Message disappears after 5 seconds
    }


    // Fetch Class Levels
    async function fetchClassLevels() {
        try {
            const response = await fetch('/api/exams/config/class-levels', { credentials: 'include' });
            if (!response.ok) {
                throw new Error('Failed to fetch class levels.');
            }
            const classLevels = await response.json();
            classLevelSelect.innerHTML = '<option value="">Select Class Level</option>';
            classLevels.forEach(level => {
                const option = document.createElement('option');
                option.value = level.level_id;
                option.textContent = level.level_name;
                classLevelSelect.appendChild(option);
            });
            allClassLevels = classLevels;
        } catch (error) {
            console.error("Error fetching class levels:", error);
            showMessage("Failed to load class levels: " + error.message, 'error');
        }
    }

    // Modified fetchSubjects: Now depends on selected class level
    async function fetchSubjects(classLevelId = null) {
        subjectSelect.innerHTML = '<option value="">Select Subject</option>'; // Reset subjects
        subjectSelect.disabled = true;

        if (!classLevelId) return;

        try {
            const response = await fetch(`/api/exams/config/subjects?class_level_id=${classLevelId}`, { credentials: 'include' }); 
            if (!response.ok) {
                throw new Error('Failed to fetch subjects for this class level.');
            }
            const subjects = await response.json();
            allSubjects = subjects;
            subjects.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject.subject_id;
                option.textContent = subject.name;
                subjectSelect.appendChild(option);
            });
            subjectSelect.disabled = false;
        } catch (error) {
            console.error("Error fetching subjects:", error);
            showMessage("Failed to load subjects: " + error.message, 'error');
        }
    }

    // Event listener for class level change
    classLevelSelect.addEventListener('change', (event) => {
        const selectedClassLevelId = event.target.value;
        fetchSubjects(selectedClassLevelId);
    });

    function addQuestionField(sectionIndex, questionData = {}) {
      questionCounter++;
      const sectionQuestionsContainer = document.getElementById(`sectionQuestions-${sectionIndex}`);
      const questionCard = document.createElement('div');
      questionCard.classList.add('question-card');
      questionCard.dataset.questionId = questionData.question_id || `new-q-${sectionIndex}-${questionCounter}`; 
      questionCard.innerHTML = `
        <div class="question-header">
          <h3>Question ${questionCounter}</h3>
          <button type="button" class="delete-question-btn" onclick="deleteQuestion(this)">Delete Question</button>
        </div>
        <div class="form-group">
          <label for="questionText-${sectionIndex}-${questionCard.dataset.questionId}">Question Text:</label>
          <textarea id="questionText-${sectionIndex}-${questionCard.dataset.questionId}" name="questionText" rows="3" required>${questionData.question_text || ''}</textarea>
        </div>
        <div class="form-grid-col-3">
          <div class="form-group">
            <label for="optionA-${sectionIndex}-${questionCard.dataset.questionId}">Option A:</label>
            <input type="text" id="optionA-${sectionIndex}-${questionCard.dataset.questionId}" name="optionA" value="${questionData.option_a || ''}" required>
          </div>
          <div class="form-group">
            <label for="optionB-${sectionIndex}-${questionCard.dataset.questionId}">Option B:</label>
            <input type="text" id="optionB-${sectionIndex}-${questionCard.dataset.questionId}" name="optionB" value="${questionData.option_b || ''}" required>
          </div>
          <div class="form-group">
            <label for="optionC-${sectionIndex}-${questionCard.dataset.questionId}">Option C:</label>
            <input type="text" id="optionC-${sectionIndex}-${questionCard.dataset.questionId}" name="optionC" value="${questionData.option_c || ''}" required>
          </div>
          <div class="form-group">
            <label for="optionD-${sectionIndex}-${questionCard.dataset.questionId}">Option D:</label>
            <input type="text" id="optionD-${sectionIndex}-${questionCard.dataset.questionId}" name="optionD" value="${questionData.option_d || ''}" required>
          </div>
          <div class="form-group">
            <label for="correctAnswer-${sectionIndex}-${questionCard.dataset.questionId}">Correct Answer:</label>
            <select id="correctAnswer-${sectionIndex}-${questionCard.dataset.questionId}" name="correctAnswer" required>
              <option value="">Select Correct Option</option>
              <option value="A" ${questionData.correct_answer === 'A' ? 'selected' : ''}>A</option>
              <option value="B" ${questionData.correct_answer === 'B' ? 'selected' : ''}>B</option>
              <option value="C" ${questionData.correct_answer === 'C' ? 'selected' : ''}>C</option>
              <option value="D" ${questionData.correct_answer === 'D' ? 'selected' : ''}>D</option>
            </select>
          </div>
          <div class="form-group">
            <label for="marks-${sectionIndex}-${questionCard.dataset.questionId}">Marks:</label>
            <input type="number" id="marks-${sectionIndex}-${questionCard.dataset.questionId}" name="marks" min="1" value="${questionData.marks || 1}" required>
          </div>
        </div>
        <div class="form-group">
          <label for="explanation-${sectionIndex}-${questionCard.dataset.questionId}">Explanation (Optional):</label>
          <textarea id="explanation-${sectionIndex}-${questionCard.dataset.questionId}" name="explanation" rows="2">${questionData.explanation || ''}</textarea>
        </div>
      `;
      sectionQuestionsContainer.appendChild(questionCard);
      updateQuestionNumbers(sectionIndex);
      updateCalculatedMarks();
    }

    function deleteQuestion(button) {
      const questionCard = button.closest('.question-card');
      const sectionIndex = questionCard.closest('.section-card').dataset.sectionId;
      questionCard.remove();
      updateQuestionNumbers(sectionIndex);
      updateCalculatedMarks();
    }

    function updateQuestionNumbers(sectionId) {
        const sectionQuestionsContainer = document.getElementById(`sectionQuestions-${sectionId}`);
        const questionCards = sectionQuestionsContainer.querySelectorAll('.question-card');
        questionCards.forEach((card, index) => {
            card.querySelector('.question-header h3').textContent = `Question ${index + 1}`;
        });
    }

    function addSectionField(sectionData = {}) {
        sectionCounter++;
        const sectionsContainer = document.getElementById('sectionsContainer');
        const sectionCard = document.createElement('div');
        sectionCard.classList.add('section-card');
        const currentSectionId = sectionData.section_id || `new-s-${Date.now()}-${sectionCounter}`;
        sectionCard.dataset.sectionId = currentSectionId;
        sectionCard.dataset.sectionIndex = sectionCounter;
        sectionCard.innerHTML = `
            <div class="section-header">
                <h2>Section ${sectionCounter}: <input type="text" class="section-name-input" name="sectionName" placeholder="e.g., Comprehension" value="${sectionData.section_name || ''}" required></h2>
                <div class="section-actions">
                    <button type="button" class="btn danger-btn" onclick="deleteSection(this)">Delete Section</button>
                </div>
            </div>
            <div class="form-group">
                <label for="sectionInstructions-${currentSectionId}">Section Instructions:</label>
                <textarea id="sectionInstructions-${currentSectionId}" name="sectionInstructions" rows="3" class="section-instructions" placeholder="Enter specific instructions for this section...">${sectionData.section_instructions || ''}</textarea>
            </div>
            <div class="section-questions" id="sectionQuestions-${currentSectionId}">
                </div>
            <button type="button" class="add-question-btn" onclick="addQuestionField('${currentSectionId}')">Add Question to Section</button>
        `;
        sectionsContainer.appendChild(sectionCard);

        if (sectionData.questions && sectionData.questions.length > 0) {
            questionCounter = 0; 
            sectionData.questions.forEach(q => addQuestionField(currentSectionId, q));
        } else {
            addQuestionField(currentSectionId);
        }
        updateSectionNumbers();
    }

    function deleteSection(button) {
        const sectionCard = button.closest('.section-card');
        sectionCard.remove();
        updateSectionNumbers();
        updateCalculatedMarks();
    }

    function updateSectionNumbers() {
        const sectionsContainer = document.getElementById('sectionsContainer');
        const sectionCards = sectionsContainer.querySelectorAll('.section-card');
        sectionCards.forEach((card, index) => {
            card.dataset.sectionIndex = index + 1;
            const sectionNameInput = card.querySelector('.section-name-input');
            const currentSectionName = sectionNameInput.value.replace(/^Section \d+: /, '').trim();
            sectionNameInput.value = `Section ${index + 1}: ${currentSectionName || 'New Section'}`;

            const currentSectionId = card.dataset.sectionId;
            
            const addQuestionBtn = card.querySelector('.add-question-btn');
            addQuestionBtn.setAttribute('onclick', `addQuestionField('${currentSectionId}')`);

            card.querySelector(`[id^="sectionInstructions-"]`).id = `sectionInstructions-${currentSectionId}`;
            card.querySelector(`[id^="sectionQuestions-"]`).id = `sectionQuestions-${currentSectionId}`;

            card.querySelectorAll('.question-card').forEach((qCard, qIndex) => {
                qCard.querySelector('.question-header h3').textContent = `Question ${qIndex + 1}`;
                qCard.querySelectorAll('[id]').forEach(el => {
                    const parts = el.id.split('-');
                    if (parts.length >= 3 && parts[1].startsWith('new-s-')) {
                        parts[1] = currentSectionId;
                    }
                    el.id = parts.join('-');
                });
            });
            updateQuestionNumbers(currentSectionId);
        });
    }


    document.getElementById('addSectionBtn').addEventListener('click', () => {
        addSectionField();
    });

    // Calculate and display total question marks
    function updateCalculatedMarks() {
        let calculatedTotalMarks = 0;
        document.querySelectorAll('.question-card').forEach(questionCard => {
            const marksInput = questionCard.querySelector('input[name="marks"]');
            if (marksInput && !isNaN(parseInt(marksInput.value))) {
                calculatedTotalMarks += parseInt(marksInput.value);
            }
        });
        document.getElementById('calculatedMarksDisplay').textContent = calculatedTotalMarks;

        const maxScoreInputVal = parseInt(maxScoreInput.value); // Changed from totalMarksInput
        const marksMismatchWarning = document.getElementById('marksMismatchWarning');
        if (maxScoreInputVal && calculatedTotalMarks !== maxScoreInputVal) {
            marksMismatchWarning.textContent = `Warning: Individual question marks sum (${calculatedTotalMarks}) does not match Total Exam Marks (${maxScoreInputVal}).`;
            marksMismatchWarning.style.display = 'block';
        } else {
            marksMismatchWarning.style.display = 'none';
        }
    }

    // Add event listener to marks input fields (call updateCalculatedMarks on change)
    sectionsContainer.addEventListener('input', (event) => {
        if (event.target.name === 'marks' && event.target.closest('.question-card')) {
            updateCalculatedMarks();
        }
    });

    // Add event listener to maxScoreInput
    maxScoreInput.addEventListener('input', updateCalculatedMarks); // Changed from totalMarksInput

     // Modified form submission: include max_score and add validation
    examForm.addEventListener('submit', async (event) => {
        event.preventDefault();
        const submitButton = event.target.querySelector('button[type="submit"]');
        submitButton.disabled = true;
        submitButton.textContent = 'Creating Exam...';
        showMessage('', 'info');

        const examTitle = document.getElementById('examTitle').value.trim();
        const examInstructions = document.getElementById('examInstructions').value.trim();
        const durationMinutes = document.getElementById('duration').value;
        const subjectId = document.getElementById('subject').value;
        const classLevelId = document.getElementById('classLevel').value;
        const maxScore = maxScoreInput.value; // Changed from totalMarks
        const passMark = passMarkInput.value;
        const startTime = startTimeInput.value;
        const endTime = endTimeInput.value;
        const examType = examTypeSelect.value;
        const isLocked = isLockedCheckbox.checked;
        const term = termSelect.value;
        const session = sessionInput.value;

        const sessionPattern = /^\d{4}-\d{4}$/;
        if (!sessionPattern.test(session)) {
            showAlert('Academic Session must be in the formatYYYY-YYYY (e.g., 2023-2024).', 'Validation Error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (!startTime || !endTime) {
            showMessage('Start Time and End Time are required.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        const startDateTime = new Date(startTime);
        const endDateTime = new Date(endTime);

        if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
            showMessage('Invalid Start Time or End Time format.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (startDateTime >= endDateTime) {
            showMessage('End Time must be after Start Time.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }


        if (!examTitle || !examInstructions || !durationMinutes || !subjectId || !classLevelId || !maxScore || !passMark || !examType || !term || !session) { // Changed totalMarks to maxScore
            showMessage('Please fill in all general exam details: Title, Class Level, Subject, Duration, Exam Type, Term, Session, Total Marks, Pass Mark, and General Instructions.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (isNaN(parseInt(durationMinutes)) || parseInt(durationMinutes) <= 0) {
            showMessage('Duration must be a positive number.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (isNaN(parseInt(maxScore)) || parseInt(maxScore) <= 0) { // Changed totalMarks to maxScore
            showMessage('Total Marks must be a positive number.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (isNaN(parseInt(passMark)) || parseInt(passMark) < 0) {
            showMessage('Pass Mark must be a non-negative number.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        const calculatedTotalMarks = parseInt(document.getElementById('calculatedMarksDisplay').textContent);
        if (maxScore && calculatedTotalMarks !== parseInt(maxScore)) { // Changed totalMarks to maxScore
            const proceed = await showConfirmation(`Warning: The sum of individual question marks (${calculatedTotalMarks}) does not match the Total Exam Marks entered (${maxScore}). Do you wish to proceed?`); // Changed totalMarks to maxScore
            if (!proceed) {
                submitButton.disabled = false;
                submitButton.textContent = 'Create Exam';
                return;
            }
        }


        const examSections = [];
        let validationFailed = false;

        document.querySelectorAll('.section-card').forEach(sectionCard => {
            if (validationFailed) return;

            const sectionNameInput = sectionCard.querySelector('.section-name-input');
            const sectionName = sectionNameInput.value.replace(/^Section \d+: /, '').trim();
            const sectionInstructions = sectionCard.querySelector('textarea[name="sectionInstructions"]').value.trim();

            if (!sectionName) {
                showMessage(`Section requires a title.`, 'error');
                validationFailed = true;
                return;
            }

            const questions = [];
            sectionCard.querySelectorAll('.question-card').forEach(questionCard => {
                if (validationFailed) return;

                const questionText = questionCard.querySelector('textarea[name="questionText"]').value.trim();
                const optionA = questionCard.querySelector('input[name="optionA"]').value.trim();
                const optionB = questionCard.querySelector('input[name="optionB"]').value.trim();
                const optionC = questionCard.querySelector('input[name="optionC"]').value.trim();
                const optionD = questionCard.querySelector('input[name="optionD"]').value.trim();
                const correctAnswer = questionCard.querySelector('select[name="correctAnswer"]').value.trim();
                const explanation = questionCard.querySelector('textarea[name="explanation"]').value.trim();
                const marks = questionCard.querySelector('input[name="marks"]').value;

                if (!questionText || !optionA || !optionB || !optionC || !optionD || !correctAnswer || !marks) {
                    showMessage(`All question fields in section "${sectionName}" must be filled.`, 'error');
                    validationFailed = true;
                    return;
                }
                if (isNaN(parseInt(marks)) || parseInt(marks) <= 0) {
                    showMessage(`Marks for all questions in section "${sectionName}" must be positive numbers.`, 'error');
                    validationFailed = true;
                    return;
                }

                questions.push({
                    question_text: questionText,
                    option_a: optionA,
                    option_b: optionB,
                    option_c: optionC,
                    option_d: optionD,
                    correct_answer: correctAnswer,
                    explanation: explanation,
                    marks: parseInt(marks)
                });
            });

            if (validationFailed) return;

            if (questions.length === 0) {
                 showMessage(`Section "${sectionName}" must have at least one question.`, 'error');
                 validationFailed = true;
                 return;
            }

            examSections.push({
                section_name: sectionName,
                section_instructions: sectionInstructions,
                questions: questions
            });
        });

        if (validationFailed) {
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        if (examSections.length === 0) {
            showMessage('The exam must have at least one section with at least one question.', 'error');
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
            return;
        }

        try {
            const response = await fetch('/api/exams', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                credentials: 'include',
                body: JSON.stringify({
                    title: examTitle, 
                    exam_instructions: examInstructions,
                    duration_minutes: parseInt(durationMinutes),
                    subject_id: parseInt(subjectId),
                    class_level_id: parseInt(classLevelId),
                    max_score: parseInt(maxScore), // Changed from total_marks
                    pass_mark: parseInt(passMark),
                    start_time: startTime,
                    end_time: endTime,
                    exam_type: examType,
                    is_locked: isLocked,
                    term: term, 
                    session: session, 
                    sections: examSections
                }),
            });

            const responseData = await response.json();
            if (response.ok) {
                showMessage('Exam created successfully! Redirecting...', 'success');
                setTimeout(() => {
                    window.location.href = 'dashboard.html';
                }, 1500);
            } else {
                showAlert(responseData.error || 'Failed to create exam.', 'Creation Error');
            }
        } catch (error) {
            console.error('Network or unexpected error:', error);
            showAlert('An unexpected error occurred: ' + error.message, 'Error');
        } finally {
            submitButton.disabled = false;
            submitButton.textContent = 'Create Exam';
        }
    });

    // Navigation (copied for self-containment)
    function createNavigationLinks(user) {
        const navLinksContainer = document.getElementById('navLinksContainer');
        navLinksContainer.innerHTML = ''; 

        const links = [
            { href: "/dashboard.html", text: "Dashboard" },
            { href: "/create-exam.html", text: "Create Exam", roles: ['admin', 'teacher'] },
            { href: "/manage-users.html", text: "Manage Users", roles: ['admin'] },
            { href: "/registration.html", text: "Register User", roles: ['admin'] },
            { href: "/admin-reports.html", text: "Student Reports", roles: ['admin'] },
            { href: "/manage-subjects.html", text: "Manage Subjects", roles: ['admin'] },
            { href: "/manage-classes.html", text: "Manage Classes", roles: ['admin'] }
        ];

        links.forEach(linkInfo => {
            const shouldDisplay = !linkInfo.roles || linkInfo.roles.some(role => {
                if (role === 'admin') return user.is_admin;
                return user.role === role;
            });

            if (shouldDisplay) {
                const listItem = document.createElement('li');
                const link = document.createElement('a');
                link.href = linkInfo.href;
                link.textContent = linkInfo.text;
                link.classList.add('nav-link');
                
                if (window.location.pathname === linkInfo.href) {
                    link.classList.add('active');
                }

                listItem.appendChild(link);
                navLinksContainer.appendChild(listItem);
            }
        });

        const logoutLinkItem = document.createElement('li');
        const logoutLink = document.createElement('button');
        logoutLink.textContent = "Logout";
        logoutLink.classList.add('btn', 'logout-btn');
        logoutLink.onclick = async () => {
            try {
                const response = await fetch('/api/users/logout', { method: 'POST', credentials: 'include' });
                if (response.ok) {
                    localStorage.clear();
                    sessionStorage.clear();
                    window.location.href = '/login.html';
                } else {
                    const errorMsg = ((await response.json().catch(()=>({}))).error || 'Please try again.');
                    showAlert('Logout failed: ' + errorMsg, 'Logout Error');
                }
            } catch (error) {
                console.error('Logout error:', error);
                showAlert('Logout failed due to a network error.', 'Logout Error');
            }
        };
        logoutLinkItem.appendChild(logoutLink);
        navLinksContainer.appendChild(logoutLinkItem);
    }

    async function loadUserData() {
        try {
            const userResponse = await fetch('/api/users/me', { credentials: 'include' });
            if (!userResponse.ok) {
                if (userResponse.status === 401) window.location.href = '/login.html';
                throw new Error('User not authenticated');
            }
            currentUser = await userResponse.json();
            createNavigationLinks(currentUser);
            return currentUser;
        } catch (error) {
            console.error("Initialization error:", error);
            showAlert(error.message || "Failed to initialize page.", 'Initialization Error');
            return null;
        }
    }

    // --- Modals for alerts and confirmations (copied for self-containment) ---
    let currentConfirmationCallback = null; 

    function showConfirmation(message) {
        return new Promise(resolve => {
            document.getElementById('confirmationMessage').textContent = message;
            document.getElementById('confirmationModal').style.display = 'flex'; 
            currentConfirmationCallback = resolve;
        });
    }

    function confirmAction(result) {
        if (currentConfirmationCallback) {
            currentConfirmationCallback(result);
            currentConfirmationCallback = null; 
        }
        closeModal('confirmationModal');
    }

    function showAlert(message, title = "Alert") {
        document.getElementById('alertTitle').textContent = title;
        document.getElementById('alertMessage').textContent = message;
        document.getElementById('alertDialog').style.display = 'flex'; 
    }

    function closeModal(modalId) {
        document.getElementById(modalId).style.display = 'none';
    }
    // --- End Modals ---


    async function loadInitialData() {
        const user = await loadUserData();
        if (user && (user.role === 'teacher' || user.is_admin)) {
            await fetchClassLevels();
            addSectionField();
            updateCalculatedMarks();
        } else {
            document.querySelector('main').innerHTML = '<h1>Access Denied</h1><p>You do not have permission to create exams.</p>';
        }
    }

    window.addEventListener('DOMContentLoaded', loadInitialData);
  </script>
  <!-- Modals HTML (add these to the end of your body tag) -->
<div id="confirmationModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Confirm Action</h2>
            <span class="close-button" onclick="closeModal('confirmationModal')">&times;</span>
        </div>
        <div class="modal-body">
            <p id="confirmationMessage"></p>
        </div>
        <div class="modal-footer">
            <button class="btn btn-secondary" onclick="confirmAction(false)">Cancel</button>
            <button class="btn btn-danger" onclick="confirmAction(true)">Confirm</button>
        </div>
    </div>
</div>

<div id="alertDialog" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="alertTitle">Alert</h2>
            <span class="close-button" onclick="closeModal('alertDialog')">&times;</span>
        </div>
        <div class="modal-body">
            <p id="alertMessage"></p>
        </div>
        <div class="modal-footer">
            <button class="btn btn-primary" onclick="closeModal('alertDialog')">OK</button>
        </div>
    </div>
</div>
</body>
</html>
